"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.solveProperSudokuAsync = exports.check3by3BoxIsValid = exports.checkColumnIsValid = exports.checkRowIsValid = void 0;
const sleep_1 = __importDefault(require("./sleep"));
const checkRowIsValid = (yIndex, arr2d) => {
    let foundNumbersInRow = [];
    for (let x = 0; x < 9; x++) {
        if (arr2d[yIndex][x] === -1) {
            continue;
        }
        if (foundNumbersInRow.includes(arr2d[yIndex][x])) {
            return false;
        }
        foundNumbersInRow.push(arr2d[yIndex][x]);
    }
    return true;
};
exports.checkRowIsValid = checkRowIsValid;
const checkColumnIsValid = (xIndex, arr2d) => {
    let foundNumbersInColumn = [];
    for (let y = 0; y < 9; y++) {
        if (arr2d[y][xIndex] === -1) {
            continue;
        }
        if (foundNumbersInColumn.includes(arr2d[y][xIndex])) {
            return false;
        }
        foundNumbersInColumn.push(arr2d[y][xIndex]);
    }
    return true;
};
exports.checkColumnIsValid = checkColumnIsValid;
const check3by3BoxIsValid = (xIndex, yIndex, arr2d) => {
    let found = [];
    const checkRowWithin3by3blockIsValid = (xIndexOffset, y) => {
        let xIndexWithin3by3Box = xIndexOffset % 3;
        if (xIndexWithin3by3Box === 0) {
            for (let x = 0; x < 3; x++) {
                if (arr2d[y][xIndexOffset + x] === -1) {
                    continue;
                }
                if (found.includes(arr2d[y][xIndexOffset + x])) {
                    return false;
                }
                found.push(arr2d[y][xIndexOffset + x]);
            }
        }
        else if (xIndexWithin3by3Box === 1) {
            for (let x = -1; x <= 1; x++) {
                if (arr2d[y][xIndexOffset + x] === -1) {
                    continue;
                }
                if (found.includes(arr2d[y][xIndexOffset + x])) {
                    return false;
                }
                found.push(arr2d[y][xIndexOffset + x]);
            }
        }
        else if (xIndexWithin3by3Box === 2) {
            for (let x = -2; x <= 0; x++) {
                if (arr2d[y][xIndexOffset + x] === -1) {
                    continue;
                }
                if (found.includes(arr2d[y][xIndexOffset + x])) {
                    return false;
                }
                found.push(arr2d[y][xIndexOffset + x]);
            }
        }
        return true;
    };
    let yIndexWithin3by3Box = yIndex % 3;
    if (yIndexWithin3by3Box === 0) {
        for (let y = 0; y < 3; y++) {
            if (!checkRowWithin3by3blockIsValid(xIndex, yIndex + y))
                return false;
        }
    }
    else if (yIndexWithin3by3Box === 1) {
        for (let y = -1; y <= 1; y++) {
            if (!checkRowWithin3by3blockIsValid(xIndex, yIndex + y))
                return false;
        }
    }
    else if (yIndexWithin3by3Box === 2) {
        for (let y = -2; y <= 0; y++) {
            if (!checkRowWithin3by3blockIsValid(xIndex, yIndex + y))
                return false;
        }
    }
    return true;
};
exports.check3by3BoxIsValid = check3by3BoxIsValid;
const numberAtPosXYIsLegal = (xIndex, yIndex, arr2d) => {
    return (0, exports.checkRowIsValid)(yIndex, arr2d) && (0, exports.checkColumnIsValid)(xIndex, arr2d) && (0, exports.check3by3BoxIsValid)(xIndex, yIndex, arr2d);
};
const solveProperSudokuRecursiveAsync = (x, y, arr2d, callStackStep) => __awaiter(void 0, void 0, void 0, function* () {
    // console.log("hm")
    return new Promise((resolve) => __awaiter(void 0, void 0, void 0, function* () {
        // console.log("run")
        if (callStackStep) {
            yield (0, sleep_1.default)(callStackStep.delayBetweenEachStepInCallStackInMillisecs);
            callStackStep === null || callStackStep === void 0 ? void 0 : callStackStep.onFunctionExecutingInCallStack(x, y, arr2d);
        }
        // if location is a clue
        if (arr2d[y][x] !== -1) {
            if (y === 8 && x === 8) {
                // end condition
                console.log("end");
                resolve(arr2d);
                return;
            }
            let result = yield solveProperSudokuRecursiveAsync(x == 8 ? 0 : x + 1, x == 8 ? y + 1 : y, arr2d, callStackStep
                ? {
                    onFunctionExecutingInCallStack: callStackStep.onFunctionExecutingInCallStack,
                    delayBetweenEachStepInCallStackInMillisecs: callStackStep.delayBetweenEachStepInCallStackInMillisecs,
                }
                : undefined);
            if (callStackStep) {
                yield (0, sleep_1.default)(callStackStep.delayBetweenEachStepInCallStackInMillisecs);
                callStackStep === null || callStackStep === void 0 ? void 0 : callStackStep.onFunctionExecutingInCallStack(x, y, arr2d);
            }
            if (result) {
                resolve(result);
                return;
            }
            // if location has no clue/number in it
        }
        else {
            for (let i = 1; i <= 9; i++) {
                let arr2dcopy = Array.from(arr2d, (arr) => arr.slice());
                arr2dcopy[y][x] = i;
                let result = undefined;
                if (numberAtPosXYIsLegal(x, y, arr2dcopy)) {
                    if (y === 8 && x === 8) {
                        // end condition
                        console.log("end");
                        resolve(arr2dcopy);
                        return;
                    }
                    result = yield solveProperSudokuRecursiveAsync(x == 8 ? 0 : x + 1, x == 8 ? y + 1 : y, arr2dcopy, callStackStep
                        ? {
                            onFunctionExecutingInCallStack: callStackStep.onFunctionExecutingInCallStack,
                            delayBetweenEachStepInCallStackInMillisecs: callStackStep.delayBetweenEachStepInCallStackInMillisecs,
                        }
                        : undefined);
                    if (callStackStep) {
                        yield (0, sleep_1.default)(callStackStep.delayBetweenEachStepInCallStackInMillisecs);
                        callStackStep === null || callStackStep === void 0 ? void 0 : callStackStep.onFunctionExecutingInCallStack(x, y, arr2d);
                    }
                }
                if (result) {
                    // console.log("back");
                    resolve(result);
                    return;
                }
                // if number in position isn't legal continue to next number for this slot -
                // or if next slot didn't find any number that worked for it
            }
        }
        // console.log("backtracking");
        // if this is reached backtrack will happen, as value of a function that has no return value is defaulted to undefined -
        // so undefined is 'returned' here implicitly
        resolve(undefined);
    }));
});
/**
 * Solves a proper sudoku puzzle (9x9 with a minimum of 17 clues) with a recursive backtracking algorithm
 * @param puzzleInput - a 9x9 2d array of numbers where -1 represents an empty cell
 * @returns a 9x9 2d array of numbers representing the solved sudoku puzzle
 */
const solveProperSudokuAsync = (puzzleInput, callStackStep) => __awaiter(void 0, void 0, void 0, function* () {
    // @ts-ignore
    if (puzzleInput[0][0]) {
        // if 2d array
        const puzzleInputAs1dArray = puzzleInput.flat();
        if (puzzleInputAs1dArray.length !== 9 * 9) {
            throw new Error("puzzle input must be of length 9 x 9");
        }
        if (nOfCluesIn1dArrayPuzzleInputIsBelow17(puzzleInputAs1dArray))
            throw new Error("puzzle input must contain a minimum of 17 clues or more");
        return (yield solveProperSudokuRecursiveAsync(0, 0, puzzleInput, callStackStep
            ? {
                onFunctionExecutingInCallStack: callStackStep.onFunctionExecutingInCallStack,
                delayBetweenEachStepInCallStackInMillisecs: callStackStep.delayBetweenEachStepInCallStackInMillisecs,
            }
            : undefined));
    }
    else {
        // if 1d array
        if (puzzleInput.length !== 9 * 9) {
            throw new Error("puzzle input must be of length 9 x 9");
        }
        if (nOfCluesIn1dArrayPuzzleInputIsBelow17(puzzleInput))
            throw new Error("puzzle input must contain a minimum of 17 clues or more");
        // @ts-ignore
        let array2dRepresentationOf1dPuzzle = convert1dArrayto2dArray(puzzleInput);
        return (yield solveProperSudokuRecursiveAsync(0, 0, array2dRepresentationOf1dPuzzle, callStackStep
            ? {
                onFunctionExecutingInCallStack: callStackStep.onFunctionExecutingInCallStack,
                delayBetweenEachStepInCallStackInMillisecs: callStackStep.delayBetweenEachStepInCallStackInMillisecs,
            }
            : undefined));
    }
});
exports.solveProperSudokuAsync = solveProperSudokuAsync;
function convert1dArrayto2dArray(arr) {
    let arr2d = [];
    for (let i = 0; i < 9; i++) {
        arr2d.push(arr.slice(i * 9, i * 9 + 9));
    }
    return arr2d;
}
function nOfCluesIn1dArrayPuzzleInputIsBelow17(puzzleInput1dArr) {
    let n = puzzleInput1dArr.filter((n) => n !== -1).length;
    return n < 17;
}
//# sourceMappingURL=sudokuSolverAsync.js.map